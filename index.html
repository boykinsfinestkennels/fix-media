<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Editor (Offline)</title>
    <style>
        /* Same styles as before */
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; display: flex; height: 100vh; }
        .left { width: 250px; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px; }
        .right { flex: 1; padding-left: 10px; display: flex; flex-direction: column; gap: 10px; }
        .drop { border: 2px dashed #007bff; padding: 10px; text-align: center; background: white; border-radius: 5px; cursor: pointer; }
        .drop.dragover { background: #e0e7ff; }
        .preview { background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex: 1; overflow: auto; }
        img, video, canvas { max-width: 100%; max-height: 100%; object-fit: contain; }
        h3 { margin: 0 0 5px; color: #007bff; }
        select, input { padding: 5px; border: 1px solid #ccc; border-radius: 3px; width: 100%; box-sizing: border-box; }
        input[type="number"] { width: 45%; margin-right: 5%; }
        button { padding: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:disabled { background: #aaa; cursor: not-allowed; }
        .status { font-size: 12px; color: #333; }
        #modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-height: 80vh; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; overflow: auto; }
        #modal-backdrop { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
        #modal-header { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        #close-modal { background: #ff4444; width: 20px; height: 20px; line-height: 20px; text-align: center; border-radius: 50%; }
        #blur-toggle { background: #ff6666; }
        #progress { display: none; width: 100%; height: 10px; }
        #page-select { display: none; }
    </style>
</head>
<body>
    <!-- Same HTML structure as before -->
    <div class="left">
        <h3>Options</h3>
        <select id="mode">
            <option value="crop">Crop/Redact</option>
            <option value="resize">Resize</option>
            <option value="trim">Trim (Video)</option>
        </select>
        <select id="size-preset" onchange="setSizePreset()">
            <option value="">Custom Size</option>
            <option value="1200x1800">4x6 (1200x1800)</option>
            <option value="1500x2100">5x7 (1500x2100)</option>
            <option value="2400x3000">8x10 (2400x3000)</option>
        </select>
        <div id="size-inputs" style="display: none;">
            <input type="number" id="width" placeholder="Width" min="1">
            <input type="number" id="height" placeholder="Height" min="1">
        </div>
        <div id="trim-inputs" style="display: none;">
            <input type="number" id="start-time" placeholder="Start (s)" min="0" step="0.1">
            <input type="number" id="end-time" placeholder="End (s)" min="0" step="0.1">
        </div>
        <select id="format">
            <option value="jpeg">JPEG (Image)</option>
            <option value="png">PNG (Image)</option>
            <option value="pdf">PDF</option>
            <option value="mp4">MP4 (Video)</option>
            <option value="mov">MOV (Video)</option>
        </select>
        <input type="text" id="filename" placeholder="Output Filename">
        <select id="page-select" onchange="loadPDFPage()"></select>
        <button id="convert" onclick="convert()">Convert</button>
        <button id="save" onclick="save()" disabled>Save</button>
        <button id="ok" onclick="process()" style="display: none;">OK</button>
        <button id="cancel" onclick="closeModal()" style="display: none; background: #ff4444;">Cancel</button>
        <div class="status" id="status">Drop a file here</div>
        <progress id="progress" value="0" max="100"></progress>
    </div>
    <div class="right">
        <div class="drop" id="drop">Drop files here<input type="file" id="file" style="display: none;" accept="image/*,video/*,.pdf"></div>
        <div class="preview">
            <h3>Original</h3>
            <div id="original"></div>
        </div>
        <div class="preview">
            <h3>Converted</h3>
            <div id="converted"></div>
        </div>
    </div>
    <div id="modal-backdrop"></div>
    <div id="modal">
        <div id="modal-header">
            <h3>Edit</h3>
            <button id="blur-toggle" onclick="toggleBlur()">Blur</button>
            <select id="redact-type">
                <option value="blur">Blur</option>
                <option value="blackout">Blackout</option>
            </select>
            <button id="close-modal" onclick="closeModal()">X</button>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    <script>
        (function() {
            const isLocal = window.location.protocol === 'file:';
            const basePath = isLocal ? './lib/' : ''; // Adjust this if lib/ is not next to app14.html
            const cdnBase = 'https://';

            function loadScript(src, onErrorMessage) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = () => {
                        console.log(`Loaded: ${src}`);
                        resolve();
                    };
                    script.onerror = () => {
                        console.error(`Failed to load: ${src}`);
                        reject(new Error(onErrorMessage));
                    };
                    document.body.appendChild(script);
                });
            }

            console.log('Starting script load...');
            console.log('Local mode:', isLocal);
            console.log('Base path:', basePath);

            Promise.all([
                loadScript(isLocal ? `${basePath}ffmpeg.min.js` : `${cdnBase}unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js`, 'Failed to load FFmpeg'),
                loadScript(isLocal ? `${basePath}pdf.min.js` : `${cdnBase}cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js`, 'Failed to load PDF.js')
            ]).then(() => {
                console.log('All scripts loaded successfully');
                initializeApp();
            }).catch(err => {
                console.error('Script loading error:', err);
                document.getElementById('status').textContent = 'Error loading libraries. Check console for details.';
            });

            function initializeApp() {
                let file, output, blurOn = false, rects = [], pages = [], baseMedia, objectURLs = [], pdfDoc = null, currentPage = 1;
                const { createFFmpeg, fetchFile } = FFmpeg;
                const ffmpeg = createFFmpeg({ 
                    log: true,
                    corePath: isLocal ? `${basePath}ffmpeg-core.js` : `${cdnBase}unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js`
                });
                const drop = document.getElementById('drop');
                const fileInput = document.getElementById('file');
                const status = document.getElementById('status');
                const mode = document.getElementById('mode');
                const widthInput = document.getElementById('width');
                const heightInput = document.getElementById('height');
                const startTimeInput = document.getElementById('start-time');
                const endTimeInput = document.getElementById('end-time');
                const convertBtn = document.getElementById('convert');
                const saveBtn = document.getElementById('save');
                const okBtn = document.getElementById('ok');
                const cancelBtn = document.getElementById('cancel');
                const canvas = document.getElementById('canvas');
                const modal = document.getElementById('modal');
                const modalBackdrop = document.getElementById('modal-backdrop');
                const progress = document.getElementById('progress');
                const pageSelect = document.getElementById('page-select');

                if (!drop) {
                    status.textContent = 'Error: Drop zone not found';
                    console.error('Drop element not found');
                    return;
                }

                (async () => {
                    try {
                        await ffmpeg.load();
                        status.textContent = 'FFmpeg loaded. Drop a file here.';
                        console.log('FFmpeg initialized');
                    } catch (e) {
                        status.textContent = 'Error loading FFmpeg';
                        console.error('FFmpeg load error:', e);
                    }
                })();
                pdfjsLib.GlobalWorkerOptions.workerSrc = isLocal ? `${basePath}pdf.worker.min.js` : `${cdnBase}cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;

                drop.addEventListener('dragover', e => {
                    e.preventDefault();
                    console.log('Dragover event triggered');
                    drop.classList.add('dragover');
                });
                drop.addEventListener('dragleave', () => {
                    console.log('Dragleave event triggered');
                    drop.classList.remove('dragover');
                });
                drop.addEventListener('drop', e => {
                    e.preventDefault();
                    console.log('Drop event triggered');
                    drop.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        loadFile(e.dataTransfer.files[0]);
                    } else {
                        status.textContent = 'No file detected in drop';
                        console.error('No files in drop event');
                    }
                });
                drop.addEventListener('click', () => {
                    console.log('Drop zone clicked');
                    fileInput.click();
                });
                fileInput.addEventListener('change', () => {
                    console.log('File input changed');
                    if (fileInput.files.length > 0) {
                        loadFile(fileInput.files[0]);
                    }
                });

                mode.addEventListener('change', () => {
                    document.getElementById('size-inputs').style.display = mode.value === 'resize' ? 'block' : 'none';
                    document.getElementById('size-preset').style.display = mode.value === 'resize' ? 'block' : 'none';
                    document.getElementById('trim-inputs').style.display = mode.value === 'trim' ? 'block' : 'none';
                });

                function setSizePreset() {
                    const preset = document.getElementById('size-preset').value;
                    if (preset) {
                        const [w, h] = preset.split('x').map(Number);
                        widthInput.value = w;
                        heightInput.value = h;
                    }
                }

                function cleanupURLs() {
                    objectURLs.forEach(url => URL.revokeObjectURL(url));
                    objectURLs = [];
                }

                function loadFile(f) {
                    console.log('Loading file:', f.name);
                    cleanupURLs();
                    file = f;
                    pages = [];
                    rects = [];
                    pdfDoc = null;
                    currentPage = 1;
                    status.textContent = 'Loading...';
                    const filename = file.name.split('.').slice(0, -1).join('.');
                    document.getElementById('filename').value = filename.replace(/[^a-zA-Z0-9_-]/g, '_');
                    if (file.type === 'application/pdf') loadPDF();
                    else if (file.type.startsWith('image/')) {
                        pageSelect.style.display = 'none';
                        if (mode.value === 'crop') editImage();
                        else showOriginal(file);
                    } else if (file.type.startsWith('video/')) {
                        pageSelect.style.display = 'none';
                        if (mode.value === 'trim') editVideo();
                        else showOriginal(file);
                    } else {
                        status.textContent = 'Unsupported file type';
                        console.error('Unsupported file type:', file.type);
                    }
                }

                async function loadPDF() {
                    const url = URL.createObjectURL(file);
                    objectURLs.push(url);
                    try {
                        pdfDoc = await pdfjsLib.getDocument(url).promise;
                        pageSelect.style.display = 'block';
                        pageSelect.innerHTML = '';
                        for (let i = 1; i <= pdfDoc.numPages; i++) {
                            const option = document.createElement('option');
                            option.value = i;
                            option.textContent = `Page ${i}`;
                            pageSelect.appendChild(option);
                        }
                        loadPDFPage();
                    } catch (e) {
                        status.textContent = 'Error loading PDF';
                        console.error('PDF load error:', e);
                    }
                }

                async function loadPDFPage() {
                    if (!pdfDoc) return;
                    currentPage = parseInt(pageSelect.value);
                    try {
                        const page = await pdfDoc.getPage(currentPage);
                        const scale = 1.5;
                        const viewport = page.getViewport({ scale });
                        const c = document.createElement('canvas');
                        c.width = viewport.width;
                        c.height = viewport.height;
                        const ctx = c.getContext('2d');
                        await page.render({ canvasContext: ctx, viewport }).promise;
                        const blob = await new Promise(resolve => c.toBlob(resolve, 'image/jpeg', 0.9));
                        pages[currentPage - 1] = blob;
                        file = new File([blob], `page_${currentPage}.jpg`, { type: 'image/jpeg' });
                        if (mode.value === 'crop') editImage(file);
                        else showOriginal(file);
                    } catch (e) {
                        status.textContent = 'Error loading PDF page';
                        console.error('PDF page load error:', e);
                    }
                }

                function editImage(base = file) {
                    baseMedia = new Image();
                    baseMedia.onload = () => {
                        canvas.width = baseMedia.width;
                        canvas.height = baseMedia.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(baseMedia, 0, 0);
                        showModal();
                        setupRedact();
                    };
                    baseMedia.onerror = () => {
                        status.textContent = 'Error loading image';
                        console.error('Image load error');
                    };
                    const url = URL.createObjectURL(base);
                    objectURLs.push(url);
                    baseMedia.src = url;
                }

                function editVideo(base = file) {
                    baseMedia = document.createElement('video');
                    baseMedia.onloadedmetadata = () => {
                        canvas.width = baseMedia.videoWidth;
                        canvas.height = baseMedia.videoHeight;
                        showModal();
                        setupVideoTrim();
                    };
                    baseMedia.onerror = () => {
                        status.textContent = 'Error loading video';
                        console.error('Video load error');
                    };
                    const url = URL.createObjectURL(base);
                    objectURLs.push(url);
                    baseMedia.src = url;
                }

                function setupRedact() {
                    const ctx = canvas.getContext('2d');
                    let start = null, dragging = false;
                    function redraw() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(baseMedia, 0, 0);
                        rects.forEach(r => redact(ctx, r));
                    }
                    canvas.onmousedown = e => {
                        if (!blurOn) return;
                        start = { x: e.offsetX, y: e.offsetY };
                        dragging = true;
                    };
                    canvas.onmousemove = e => {
                        if (!blurOn || !dragging) return;
                        redraw();
                        const end = { x: e.offsetX, y: e.offsetY };
                        const tempRect = { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y), w: Math.abs(end.x - start.x), h: Math.abs(end.y - start.y) };
                        redact(ctx, tempRect);
                    };
                    canvas.onmouseup = e => {
                        if (!blurOn) return;
                        const end = { x: e.offsetX, y: e.offsetY };
                        dragging = false;
                        rects.push({ x: Math.min(start.x, end.x), y: Math.min(start.y, end.y), w: Math.abs(end.x - start.x), h: Math.abs(end.y - start.y) });
                        redraw();
                    };
                }

                function setupVideoTrim() {
                    const ctx = canvas.getContext('2d');
                    baseMedia.currentTime = 0;
                    baseMedia.onseeked = () => {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(baseMedia, 0, 0);
                    };
                }

                function redact(ctx, rect) {
                    const type = document.getElementById('redact-type').value;
                    if (type === 'blur') {
                        ctx.filter = 'blur(10px)';
                        ctx.drawImage(baseMedia, rect.x, rect.y, rect.w, rect.h, rect.x, rect.y, rect.w, rect.h);
                        ctx.filter = 'none';
                    } else {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                    }
                }

                function toggleBlur() {
                    blurOn = !blurOn;
                    document.getElementById('blur-toggle').textContent = blurOn ? 'Crop' : 'Blur';
                }

                function showModal() {
                    modal.style.display = 'block';
                    modalBackdrop.style.display = 'block';
                    okBtn.style.display = 'block';
                    cancelBtn.style.display = 'block';
                }

                function closeModal() {
                    modal.style.display = 'none';
                    modalBackdrop.style.display = 'none';
                    okBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    blurOn = false;
                    rects = [];
                    showOriginal(file);
                }

                function process() {
                    const ctx = canvas.getContext('2d');
                    if (mode.value === 'crop' && blurOn) {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(baseMedia, 0, 0);
                        rects.forEach(r => redact(ctx, r));
                        canvas.toBlob(blob => {
                            pages[currentPage - 1] = blob;
                            file = new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), { type: 'image/jpeg' });
                            closeModal();
                        }, 'image/jpeg', 0.9);
                    } else if (mode.value === 'resize') {
                        const w = parseInt(widthInput.value) || baseMedia.width || baseMedia.videoWidth;
                        const h = parseInt(heightInput.value) || baseMedia.height || baseMedia.videoHeight;
                        if (!w || !h || w <= 0 || h <= 0) {
                            status.textContent = 'Please enter valid width and height values';
                            return;
                        }
                        canvas.width = w;
                        canvas.height = h;
                        ctx.clearRect(0, 0, w, h);
                        ctx.drawImage(baseMedia, 0, 0, w, h);
                        canvas.toBlob(blob => {
                            pages[currentPage - 1] = blob;
                            const filename = document.getElementById('filename').value || 'resized_media';
                            file = new File([blob], `${filename}.jpg`, { type: 'image/jpeg' });
                            showOriginal(blob);
                            closeModal();
                            convertBtn.disabled = false;
                        }, 'image/jpeg', 0.9);
                    } else if (mode.value === 'trim') {
                        closeModal();
                    }
                }

                function showOriginal(f) {
                    const original = document.getElementById('original');
                    original.innerHTML = '';
                    if (f.type.startsWith('image/')) {
                        const img = new Image();
                        img.onload = () => {
                            original.appendChild(img);
                            status.textContent = `Original: ${img.width}x${img.height}, ${formatSize(f.size)}${pdfDoc ? ` (Page ${currentPage}/${pdfDoc.numPages})` : ''}`;
                        };
                        img.onerror = () => {
                            status.textContent = 'Error showing original';
                            console.error('Image display error');
                        };
                        const url = URL.createObjectURL(f);
                        objectURLs.push(url);
                        img.src = url;
                    } else if (f.type.startsWith('video/')) {
                        const video = document.createElement('video');
                        video.controls = true;
                        video.onloadedmetadata = () => {
                            original.appendChild(video);
                            status.textContent = `Original: ${video.videoWidth}x${video.videoHeight}, ${formatSize(f.size)}, ${video.duration.toFixed(1)}s`;
                        };
                        video.onerror = () => {
                            status.textContent = 'Error showing original';
                            console.error('Video display error');
                        };
                        const url = URL.createObjectURL(f);
                        objectURLs.push(url);
                        video.src = url;
                    }
                }

                async function convert() {
                    if (!file) { 
                        status.textContent = 'No file selected'; 
                        return; 
                    }
                    const format = document.getElementById('format').value;
                    status.textContent = 'Converting...';
                    progress.style.display = 'block';
                    progress.value = 0;
                    const src = pages[currentPage - 1] || file;

                    if (format === 'pdf' && pdfDoc) {
                        const pageBlobs = [];
                        for (let i = 1; i <= pdfDoc.numPages; i++) {
                            const page = await pdfDoc.getPage(i);
                            const scale = 1.5;
                            const viewport = page.getViewport({ scale });
                            const c = document.createElement('canvas');
                            c.width = viewport.width;
                            c.height = viewport.height;
                            const ctx = c.getContext('2d');
                            await page.render({ canvasContext: ctx, viewport }).promise;
                            const blob = pages[i - 1] || await new Promise(resolve => c.toBlob(resolve, 'image/jpeg', 0.9));
                            pageBlobs.push(blob);
                        }
                        const pdfBlob = await createPDF(pageBlobs);
                        output = new File([pdfBlob], `${document.getElementById('filename').value || 'output'}.pdf`, { type: 'application/pdf' });
                        showConverted(output);
                        progress.style.display = 'none';
                    } else if (format === 'jpeg' || format === 'png') {
                        const img = new Image();
                        img.onload = () => {
                            const c = document.createElement('canvas');
                            c.width = img.width;
                            c.height = img.height;
                            c.getContext('2d').drawImage(img, 0, 0);
                            c.toBlob(blob => {
                                output = new File([blob], `${document.getElementById('filename').value || 'output'}.${format}`, { type: `image/${format}` });
                                showConverted(output);
                                progress.style.display = 'none';
                            }, `image/${format}`, 0.9);
                        };
                        img.onerror = () => {
                            status.textContent = 'Error converting';
                            console.error('Image conversion error');
                            progress.style.display = 'none';
                        };
                        img.src = URL.createObjectURL(src);
                    } else if (format === 'mp4' || format === 'mov') {
                        try {
                            await ffmpeg.load();
                            const inputName = 'input.' + file.name.split('.').pop();
                            const outputName = `${document.getElementById('filename').value || 'output'}.${format}`;
                            ffmpeg.FS('writeFile', inputName, await fetchFile(file));
                            
                            let args = ['-i', inputName];
                            if (mode.value === 'trim') {
                                const start = parseFloat(startTimeInput.value) || 0;
                                const end = parseFloat(endTimeInput.value) || Infinity;
                                if (end > start) {
                                    args.push('-ss', start.toString(), '-t', (end - start).toString());
                                }
                            }
                            if (mode.value === 'resize') {
                                const w = parseInt(widthInput.value) || -1;
                                const h = parseInt(heightInput.value) || -1;
                                if (w > 0 && h > 0) {
                                    args.push('-vf', `scale=${w}:${h}`);
                                }
                            }
                            args.push('-c:v', 'libx264', '-preset', 'fast', outputName);

                            ffmpeg.setProgress(({ ratio }) => {
                                progress.value = ratio * 100;
                            });
                            await ffmpeg.run(...args);
                            const data = ffmpeg.FS('readFile', outputName);
                            output = new File([data.buffer], outputName, { type: `video/${format}` });
                            ffmpeg.FS('unlink', inputName);
                            ffmpeg.FS('unlink', outputName);
                            showConverted(output);
                            progress.style.display = 'none';
                        } catch (e) {
                            status.textContent = 'Error converting video';
                            console.error('Video conversion error:', e);
                            progress.style.display = 'none';
                        }
                    }
                }

                async function createPDF(pageBlobs) {
                    const pdf = `%PDF-1.4\n`;
                    let offset = pdf.length, xref = [], content = [];
                    for (let i = 0; i < pageBlobs.length; i++) {
                        const img = new Image();
                        const url = URL.createObjectURL(pageBlobs[i]);
                        objectURLs.push(url);
                        img.src = url;
                        await new Promise(r => img.onload = r);
                        const obj = `${i * 2 + 1} 0 obj\n<< /Type /XObject /Subtype /Image /Width ${img.width} /Height ${img.height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${pageBlobs[i].size} >>\nstream\n`;
                        content.push(obj);
                        const stream = await pageBlobs[i].arrayBuffer();
                        content.push(new TextDecoder().decode(stream));
                        content.push(`\nendstream\nendobj\n`);
                        xref.push({ num: i * 2 + 1, offset });

                        const page = `${i * 2 + 2} 0 obj\n<< /Type /Page /Parent 2 0 R /Resources << /XObject << /I${i} ${i * 2 + 1} 0 R >> >> /MediaBox [0 0 ${img.width} ${img.height}] /Contents [${i * 2 + 3} 0 R] >>\nendobj\n`;
                        content.push(page);
                        xref.push({ num: i * 2 + 2, offset });

                        const cmd = `${i * 2 + 3} 0 obj\n<< /Length 50 >> stream\nq ${img.width} 0 0 ${img.height} 0 0 cm /I${i} Do Q\nendstream\nendobj\n`;
                        content.push(cmd);
                        xref.push({ num: i * 2 + 3, offset });
                    }
                    const catalog = `1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n`;
                    const pagesObj = `2 0 obj\n<< /Type /Pages /Kids [${Array.from({ length: pageBlobs.length }, (_, i) => `${i * 2 + 2} 0 R`).join(' ')}] /Count ${pageBlobs.length} >>\nendobj\n`;
                    content.unshift(catalog, pagesObj);
                    xref.unshift({ num: 1, offset: pdf.length }, { num: 2, offset: pdf.length + catalog.length });

                    let out = pdf + content.join('');
                    const xrefStart = out.length;
                    out += `xref\n0 ${xref.length + 1}\n0000000000 65535 f \n`;
                    xref.forEach(x => out += `${x.offset.toString().padStart(10, '0')} 00000 n \n`);
                    out += `trailer\n<< /Size ${xref.length + 1} /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`;
                    return new Blob([out], { type: 'application/pdf' });
                }

                function showConverted(f) {
                    const converted = document.getElementById('converted');
                    converted.innerHTML = '';
                    if (f.type === 'application/pdf') {
                        converted.textContent = 'PDF (no preview)';
                        status.textContent = `Converted: ${formatSize(f.size)}`;
                        saveBtn.disabled = false;
                    } else if (f.type.startsWith('image/')) {
                        const img = new Image();
                        img.onload = () => {
                            converted.appendChild(img);
                            status.textContent = `Converted: ${img.width}x${img.height}, ${formatSize(f.size)}`;
                            saveBtn.disabled = false;
                        };
                        img.onerror = () => {
                            status.textContent = 'Error showing converted';
                            console.error('Converted image display error');
                        };
                        const url = URL.createObjectURL(f);
                        objectURLs.push(url);
                        img.src = url;
                    } else if (f.type.startsWith('video/')) {
                        const video = document.createElement('video');
                        video.controls = true;
                        video.onloadedmetadata = () => {
                            converted.appendChild(video);
                            status.textContent = `Converted: ${video.videoWidth}x${video.videoHeight}, ${formatSize(f.size)}, ${video.duration.toFixed(1)}s`;
                            saveBtn.disabled = false;
                        };
                        video.onerror = () => {
                            status.textContent = 'Error showing converted';
                            console.error('Converted video display error');
                        };
                        const url = URL.createObjectURL(f);
                        objectURLs.push(url);
                        video.src = url;
                    }
                }

                function save() {
                    if (!output) { 
                        status.textContent = 'Nothing to save'; 
                        return; 
                    }
                    const url = URL.createObjectURL(output);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = output.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    status.textContent = 'Saved';
                }

                function formatSize(bytes) {
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                }
            }
        })();
    </script>
</body>
</html>
