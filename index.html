<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Editor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; display: flex; height: 100vh; }
        .left { width: 250px; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px; }
        .right { flex: 1; padding-left: 10px; display: flex; flex-direction: column; gap: 10px; }
        .drop { border: 2px dashed #007bff; padding: 10px; text-align: center; background: white; border-radius: 5px; cursor: pointer; }
        .drop.dragover { background: #e0e7ff; }
        .preview { background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex: 1; overflow: auto; }
        img, video, canvas { max-width: 100%; max-height: 100%; object-fit: contain; }
        h3 { margin: 0 0 5px; color: #007bff; }
        select, input { padding: 5px; border: 1px solid #ccc; border-radius: 3px; width: 100%; box-sizing: border-box; }
        input[type="number"] { width: 45%; margin-right: 5%; }
        button { padding: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        button:disabled { background: #aaa; cursor: not-allowed; }
        .status { font-size: 12px; color: #333; }
        #modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-height: 80vh; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1000; overflow: auto; }
        #modal-backdrop { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
        #modal-header { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        #close-modal { background: #ff4444; width: 20px; height: 20px; line-height: 20px; text-align: center; border-radius: 50%; }
        #blur-toggle { background: #ff6666; }
        #progress { display: none; width: 100%; height: 10px; }
        #page-select { display: none; }
    </style>
</head>
<body>
    <div class="left">
        <h3>Options</h3>
        <select id="mode">
            <option value="crop">Crop/Redact</option>
            <option value="resize">Resize</option>
            <option value="trim">Trim (Video)</option>
        </select>
        <select id="size-preset">
            <option value="">Custom Size</option>
            <option value="1200x1800">4x6 (1200x1800)</option>
            <option value="1500x2100">5x7 (1500x2100)</option>
            <option value="2400x3000">8x10 (2400x3000)</option>
        </select>
        <div id="size-inputs" style="display: none;">
            <input type="number" id="width" placeholder="Width" min="1">
            <input type="number" id="height" placeholder="Height" min="1">
        </div>
        <div id="trim-inputs" style="display: none;">
            <input type="number" id="start-time" placeholder="Start (s)" min="0" step="0.1">
            <input type="number" id="end-time" placeholder="End (s)" min="0" step="0.1">
        </div>
        <select id="format">
            <option value="jpeg">JPEG (Image)</option>
            <option value="png">PNG (Image)</option>
            <option value="pdf">PDF</option>
            <option value="mp4">MP4 (Video)</option>
            <option value="mov">MOV (Video)</option>
        </select>
        <input type="text" id="filename" placeholder="Output Filename">
        <select id="page-select"></select>
        <button id="convert">Convert</button>
        <button id="save" disabled>Save</button>
        <button id="ok" style="display: none;">OK</button>
        <button id="cancel" style="display: none; background: #ff4444;">Cancel</button>
        <div class="status" id="status">Drop a file here</div>
        <progress id="progress" value="0" max="100"></progress>
    </div>
    <div class="right">
        <div class="drop" id="drop">Drop files here<input type="file" id="file" style="display: none;" accept="image/*,video/*,.pdf"></div>
        <div class="preview">
            <h3>Original</h3>
            <div id="original"></div>
        </div>
        <div class="preview">
            <h3>Converted</h3>
            <div id="converted"></div>
        </div>
    </div>
    <div id="modal-backdrop"></div>
    <div id="modal">
        <div id="modal-header">
            <h3>Edit</h3>
            <button id="blur-toggle">Blur</button>
            <select id="redact-type">
                <option value="blur">Blur</option>
                <option value="blackout">Blackout</option>
            </select>
            <button id="close-modal">X</button>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    <script>
        (function() {
            const isLocal = window.location.protocol === 'file:';
            const basePath = isLocal ? './lib/' : '';
            const cdnBase = 'https://';

            function loadScript(src, onErrorMessage) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = () => { console.log(`Loaded: ${src}`); resolve(); };
                    script.onerror = () => { console.error(`Failed to load: ${src}`); reject(new Error(onErrorMessage)); };
                    document.body.appendChild(script);
                });
            }

            console.log('Starting script load...');
            console.log('Local mode:', isLocal);
            console.log('Base path:', basePath);

            let file, output, blurOn = false, rects = [], pages = [], baseMedia, objectURLs = [], pdfDoc = null, currentPage = 1;
            let ffmpeg;

            Promise.all([
                loadScript(isLocal ? `${basePath}ffmpeg.min.js` : `${cdnBase}unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js`, 'Failed to load FFmpeg'),
                loadScript(isLocal ? `${basePath}pdf.min.js` : `${cdnBase}cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js`, 'Failed to load PDF.js')
            ]).then(() => {
                console.log('All scripts loaded successfully');
                const { createFFmpeg, fetchFile } = FFmpeg;
                ffmpeg = createFFmpeg({ 
                    log: true,
                    corePath: isLocal ? `${basePath}ffmpeg-core.js` : `${cdnBase}unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js`,
                    worker: false,
                    wasm: true,
                    args: ['-threads', '1'] // Force single-threaded
                });
                pdfjsLib.GlobalWorkerOptions.workerSrc = isLocal ? `${basePath}pdf.worker.min.js` : `${cdnBase}cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js`;
                initializeApp();
            }).catch(err => {
                console.error('Script loading error:', err);
                document.getElementById('status').textContent = 'Error loading libraries. Check console for details.';
            });

            function initializeApp() {
                const drop = document.getElementById('drop');
                const fileInput = document.getElementById('file');
                const status = document.getElementById('status');
                const mode = document.getElementById('mode');
                const widthInput = document.getElementById('width');
                const heightInput = document.getElementById('height');
                const startTimeInput = document.getElementById('start-time');
                const endTimeInput = document.getElementById('end-time');
                const convertBtn = document.getElementById('convert');
                const saveBtn = document.getElementById('save');
                const okBtn = document.getElementById('ok');
                const cancelBtn = document.getElementById('cancel');
                const canvas = document.getElementById('canvas');
                const modal = document.getElementById('modal');
                const modalBackdrop = document.getElementById('modal-backdrop');
                const progress = document.getElementById('progress');
                const pageSelect = document.getElementById('page-select');
                const blurToggle = document.getElementById('blur-toggle');
                const closeModalBtn = document.getElementById('close-modal');
                const sizePreset = document.getElementById('size-preset');

                if (!drop) {
                    status.textContent = 'Error: Drop zone not found';
                    console.error('Drop element not found');
                    return;
                }

                (async () => {
                    try {
                        await ffmpeg.load();
                        status.textContent = 'FFmpeg loaded. Drop a file here.';
                        console.log('FFmpeg initialized');
                    } catch (e) {
                        status.textContent = 'Error loading FFmpeg';
                        console.error('FFmpeg load error:', e);
                    }
                })();

                drop.addEventListener('dragover', e => {
                    e.preventDefault();
                    console.log('Dragover event triggered');
                    drop.classList.add('dragover');
                });
                drop.addEventListener('dragleave', () => {
                    console.log('Dragleave event triggered');
                    drop.classList.remove('dragover');
                });
                drop.addEventListener('drop', e => {
                    e.preventDefault();
                    console.log('Drop event triggered');
                    drop.classList.remove('dragover');
                    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        loadFile(e.dataTransfer.files[0]);
                    } else {
                        status.textContent = 'No file detected in drop';
                        console.error('No files in drop event');
                    }
                });
                drop.addEventListener('click', () => {
                    console.log('Drop zone clicked');
                    fileInput.click();
                });
                fileInput.addEventListener('change', () => {
                    console.log('File input changed');
                    if (fileInput.files.length > 0) {
                        loadFile(fileInput.files[0]);
                    }
                });

                mode.addEventListener('change', updateMode);
                sizePreset.addEventListener('change', setSizePreset);
                convertBtn.addEventListener('click', convert);
                saveBtn.addEventListener('click', save);
                okBtn.addEventListener('click', process);
                cancelBtn.addEventListener('click', closeModal);
                blurToggle.addEventListener('click', toggleBlur);
                closeModalBtn.addEventListener('click', closeModal);
                pageSelect.addEventListener('change', loadPDFPage);
            }

            function updateMode() {
                const mode = document.getElementById('mode');
                document.getElementById('size-inputs').style.display = mode.value === 'resize' ? 'block' : 'none';
                document.getElementById('size-preset').style.display = mode.value === 'resize' ? 'block' : 'none';
                document.getElementById('trim-inputs').style.display = mode.value === 'trim' ? 'block' : 'none';
            }

            function setSizePreset() {
                const preset = document.getElementById('size-preset').value;
                if (preset) {
                    const [w, h] = preset.split('x').map(Number);
                    document.getElementById('width').value = w;
                    document.getElementById('height').value = h;
                }
            }

            function cleanupURLs() {
                objectURLs.forEach(url => URL.revokeObjectURL(url));
                objectURLs = [];
            }

            function loadFile(f) {
                console.log('Loading file:', f.name);
                cleanupURLs();
                file = f;
                pages = [];
                rects = [];
                pdfDoc = null;
                currentPage = 1;
                const status = document.getElementById('status');
                status.textContent = 'Loading...';
                const filename = file.name.split('.').slice(0, -1).join('.');
                document.getElementById('filename').value = filename.replace(/[^a-zA-Z0-9_-]/g, '_');
                if (file.type === 'application/pdf') loadPDF();
                else if (file.type.startsWith('image/')) {
                    document.getElementById('page-select').style.display = 'none';
                    if (document.getElementById('mode').value === 'crop') editImage();
                    else showOriginal(file);
                } else if (file.type.startsWith('video/')) {
                    document.getElementById('page-select').style.display = 'none';
                    if (document.getElementById('mode').value === 'trim') editVideo();
                    else showOriginal(file);
                } else {
                    status.textContent = 'Unsupported file type';
                    console.error('Unsupported file type:', file.type);
                }
            }

            async function loadPDF() {
                const url = URL.createObjectURL(file);
                objectURLs.push(url);
                try {
                    pdfDoc = await pdfjsLib.getDocument(url).promise;
                    const pageSelect = document.getElementById('page-select');
                    pageSelect.style.display = 'block';
                    pageSelect.innerHTML = '';
                    for (let i = 1; i <= pdfDoc.numPages; i++) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `Page ${i}`;
                        pageSelect.appendChild(option);
                    }
                    loadPDFPage();
                } catch (e) {
                    document.getElementById('status').textContent = 'Error loading PDF';
                    console.error('PDF load error:', e);
                }
            }

            async function loadPDFPage() {
                if (!pdfDoc) return;
                currentPage = parseInt(document.getElementById('page-select').value);
                try {
                    const page = await pdfDoc.getPage(currentPage);
                    const scale = 1.5;
                    const viewport = page.getViewport({ scale });
                    const c = document.createElement('canvas');
                    c.width = viewport.width;
                    c.height = viewport.height;
                    const ctx = c.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport }).promise;
                    const blob = await new Promise(resolve => c.toBlob(resolve, 'image/jpeg', 0.9));
                    pages[currentPage - 1] = blob;
                    file = new File([blob], `page_${currentPage}.jpg`, { type: 'image/jpeg' });
                    if (document.getElementById('mode').value === 'crop') editImage(file);
                    else showOriginal(file);
                } catch (e) {
                    document.getElementById('status').textContent = 'Error loading PDF page';
                    console.error('PDF page load error:', e);
                }
            }

            function editImage(base = file) {
                baseMedia = new Image();
                baseMedia.onload = () => {
                    const canvas = document.getElementById('canvas');
                    canvas.width = baseMedia.width;
                    canvas.height = baseMedia.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(baseMedia, 0, 0);
                    showModal();
                    setupRedact();
                };
                baseMedia.onerror = () => {
                    document.getElementById('status').textContent = 'Error loading image';
                    console.error('Image load error');
                };
                const url = URL.createObjectURL(base);
                objectURLs.push(url);
                baseMedia.src = url;
            }

            function editVideo(base = file) {
                baseMedia = document.createElement('video');
                baseMedia.onloadedmetadata = () => {
                    const canvas = document.getElementById('canvas');
                    canvas.width = baseMedia.videoWidth;
                    canvas.height = baseMedia.videoHeight;
                    showModal();
                    setupVideoTrim();
                };
                baseMedia.onerror = () => {
                    document.getElementById('status').textContent = 'Error loading video';
                    console.error('Video load error');
                };
                const url = URL.createObjectURL(base);
                objectURLs.push(url);
                baseMedia.src = url;
            }

            function setupRedact() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                let start = null, dragging = false;
                function redraw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(baseMedia, 0, 0);
                    rects.forEach(r => redact(ctx, r));
                }
                canvas.onmousedown = e => {
                    if (!blurOn) return;
                    start = { x: e.offsetX, y: e.offsetY };
                    dragging = true;
                };
                canvas.onmousemove = e => {
                    if (!blurOn || !dragging) return;
                    redraw();
                    const end = { x: e.offsetX, y: e.offsetY };
                    const tempRect = { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y), w: Math.abs(end.x - start.x), h: Math.abs(end.y - start.y) };
                    redact(ctx, tempRect);
                };
                canvas.onmouseup = e => {
                    if (!blurOn) return;
                    const end = { x: e.offsetX, y: e.offsetY };
                    dragging = false;
                    rects.push({ x: Math.min(start.x, end.x), y: Math.min(start.y, end.y), w: Math.abs(end.x - start.x), h: Math.abs(end.y - start.y) });
                    redraw();
                };
            }

            function setupVideoTrim() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                baseMedia.currentTime = 0;
                baseMedia.onseeked = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(baseMedia, 0, 0);
                };
            }

            function redact(ctx, rect) {
                const type = document.getElementById('redact-type').value;
                if (type === 'blur') {
                    ctx.filter = 'blur(10px)';
                    ctx.drawImage(baseMedia, rect.x, rect.y, rect.w, rect.h, rect.x, rect.y, rect.w, rect.h);
                    ctx.filter = 'none';
                } else {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                }
            }

            function toggleBlur() {
                blurOn = !blurOn;
                document.getElementById('blur-toggle').textContent = blurOn ? 'Crop' : 'Blur';
            }

            function showModal() {
                document.getElementById('modal').style.display = 'block';
                document.getElementById('modal-backdrop').style.display = 'block';
                document.getElementById('ok').style.display = 'block';
                document.getElementById('cancel').style.display = 'block';
            }

            function closeModal() {
                document.getElementById('modal').style.display = 'none';
                document.getElementById('modal-backdrop').style.display = 'none';
                document.getElementById('ok').style.display = 'none';
                document.getElementById('cancel').style.display = 'none';
                blurOn = false;
                rects = [];
                showOriginal(file);
            }

            function process() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const mode = document.getElementById('mode').value;
                if (mode === 'crop' && blurOn) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(baseMedia, 0, 0);
                    rects.forEach(r => redact(ctx, r));
                    canvas.toBlob(blob => {
                        pages[currentPage - 1] = blob;
                        file = new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), { type: 'image/jpeg' });
                        closeModal();
                    }, 'image/jpeg', 0.9);
                } else if (mode === 'resize') {
                    const w = parseInt(document.getElementById('width').value) || baseMedia.width || baseMedia.videoWidth;
                    const h = parseInt(document.getElementById('height').value) || baseMedia.height || baseMedia.videoHeight;
                    if (!w || !h || w <= 0 || h <= 0) {
                        document.getElementById('status').textContent = 'Please enter valid width and height values';
                        return;
                    }
                    canvas.width = w;
                    canvas.height = h;
                    ctx.clearRect(0, 0, w, h);
                    ctx.drawImage(baseMedia, 0, 0, w, h);
                    canvas.toBlob(blob => {
                        pages[currentPage - 1] = blob;
                        const filename = document.getElementById('filename').value || 'resized_media';
                        file = new File([blob], `${filename}.jpg`, { type: 'image/jpeg' });
                        showOriginal(blob);
                        closeModal();
                        document.getElementById('convert').disabled = false;
                    }, 'image/jpeg', 0.9);
                } else if (mode === 'trim') {
                    closeModal();
                }
            }

            function showOriginal(f) {
                const original = document.getElementById('original');
                original.innerHTML = '';
                if (f.type.startsWith('image/')) {
                    const img = new Image();
                    img.onload = () => {
                        original.appendChild(img);
                        document.getElementById('status').textContent = `Original: ${img.width}x${img.height}, ${formatSize(f.size)}${pdfDoc ? ` (Page ${currentPage}/${pdfDoc.numPages})` : ''}`;
                    };
                    img.onerror = () => {
                        document.getElementById('status').textContent = 'Error showing original';
                        console.error('Image display error');
                    };
                    const url = URL.createObjectURL(f);
                    objectURLs.push(url);
                    img.src = url;
                } else if (f.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.onloadedmetadata = () => {
                        original.appendChild(video);
                        document.getElementById('status').textContent = `Original: ${video.videoWidth}x${video.videoHeight}, ${formatSize(f.size)}, ${video.duration.toFixed(1)}s`;
                    };
                    video.onerror = () => {
                        document.getElementById('status').textContent = 'Error showing original';
                        console.error('Video display error');
                    };
                    const url = URL.createObjectURL(f);
                    objectURLs.push(url);
                    video.src = url;
                }
            }

            async function convert() {
                if (!file) { 
                    document.getElementById('status').textContent = 'No file selected'; 
                    return; 
                }
                const format = document.getElementById('format').value;
                document.getElementById('status').textContent = 'Converting...';
                document.getElementById('progress').style.display = 'block';
                document.getElementById('progress').value = 0;
                const src = pages[currentPage - 1] || file;

                if (format === 'pdf' && pdfDoc) {
                    const pageBlobs = [];
                    for (let i = 1; i <= pdfDoc.numPages; i++) {
                        const page = await pdfDoc.getPage(i);
                        const scale = 1.5;
                        const viewport = page.getViewport({ scale });
                        const c = document.createElement('canvas');
                        c.width = viewport.width;
                        c.height = viewport.height;
                        const ctx = c.getContext('2d');
                        await page.render({ canvasContext: ctx, viewport }).promise;
                        const blob = pages[i - 1] || await new Promise(resolve => c.toBlob(resolve, 'image/jpeg', 0.9));
                        pageBlobs.push(blob);
                    }
                    const pdfBlob = await createPDF(pageBlobs);
                    output = new File([pdfBlob], `${document.getElementById('filename').value || 'output'}.pdf`, { type: 'application/pdf' });
                    showConverted(output);
                    document.getElementById('progress').style.display = 'none';
                } else if (format === 'jpeg' || format === 'png') {
                    const img = new Image();
                    img.onload = () => {
                        const c = document.createElement('canvas');
                        c.width = img.width;
                        c.height = img.height;
                        c.getContext('2d').drawImage(img, 0, 0);
                        c.toBlob(blob => {
                            output = new File([blob], `${document.getElementById('filename').value || 'output'}.${format}`, { type: `image/${format}` });
                            showConverted(output);
                            document.getElementById('progress').style.display = 'none';
                        }, `image/${format}`, 0.9);
                    };
                    img.onerror = () => {
                        document.getElementById('status').textContent = 'Error converting';
                        console.error('Image conversion error');
                        document.getElementById('progress').style.display = 'none';
                    };
                    img.src = URL.createObjectURL(src);
                } else if (format === 'mp4' || format === 'mov') {
                    try {
                        const inputName = 'input.' + file.name.split('.').pop();
                        const outputName = `${document.getElementById('filename').value || 'output'}.${format}`;
                        ffmpeg.FS('writeFile', inputName, await FFmpeg.fetchFile(file));
                        
                        let args = ['-i', inputName];
                        if (document.getElementById('mode').value === 'trim') {
                            const start = parseFloat(document.getElementById('start-time').value) || 0;
                            const end = parseFloat(document.getElementById('end-time').value) || Infinity;
                            if (end > start) {
                                args.push('-ss', start.toString(), '-t', (end - start).toString());
                            }
                        }
                        if (document.getElementById('mode').value === 'resize') {
                            const w = parseInt(document.getElementById('width').value) || -1;
                            const h = parseInt(document.getElementById('height').value) || -1;
                            if (w > 0 && h > 0) {
                                args.push('-vf', `scale=${w}:${h}`);
                            }
                        }
                        args.push('-c:v', 'libx264', '-preset', 'fast', outputName);

                        ffmpeg.setProgress(({ ratio }) => {
                            document.getElementById('progress').value = ratio * 100;
                        });
                        await ffmpeg.run(...args);
                        const data = ffmpeg.FS('readFile', outputName);
                        output = new File([data.buffer], outputName, { type: `video/${format}` });
                        ffmpeg.FS('unlink', inputName);
                        ffmpeg.FS('unlink', outputName);
                        showConverted(output);
                        document.getElementById('progress').style.display = 'none';
                    } catch (e) {
                        document.getElementById('status').textContent = 'Error converting video';
                        console.error('Video conversion error:', e);
                        document.getElementById('progress').style.display = 'none';
                    }
                }
            }

            async function createPDF(pageBlobs) {
                const pdf = `%PDF-1.4\n`;
                let offset = pdf.length, xref = [], content = [];
                for (let i = 0; i < pageBlobs.length; i++) {
                    const img = new Image();
                    const url = URL.createObjectURL(pageBlobs[i]);
                    objectURLs.push(url);
                    img.src = url;
                    await new Promise(r => img.onload = r);
                    const obj = `${i * 2 + 1} 0 obj\n<< /Type /XObject /Subtype /Image /Width ${img.width} /Height ${img.height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${pageBlobs[i].size} >>\nstream\n`;
                    content.push(obj);
                    const stream = await pageBlobs[i].arrayBuffer();
                    content.push(new TextDecoder().decode(stream));
                    content.push(`\nendstream\nendobj\n`);
                    xref.push({ num: i * 2 + 1, offset });

                    const page = `${i * 2 + 2} 0 obj\n<< /Type /Page /Parent 2 0 R /Resources << /XObject << /I${i} ${i * 2 + 1} 0 R >> >> /MediaBox [0 0 ${img.width} ${img.height}] /Contents [${i * 2 + 3} 0 R] >>\nendobj\n`;
                    content.push(page);
                    xref.push({ num: i * 2 + 2, offset });

                    const cmd = `${i * 2 + 3} 0 obj\n<< /Length 50 >> stream\nq ${img.width} 0 0 ${img.height} 0 0 cm /I${i} Do Q\nendstream\nendobj\n`;
                    content.push(cmd);
                    xref.push({ num: i * 2 + 3, offset });
                }
                const catalog = `1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n`;
                const pagesObj = `2 0 obj\n<< /Type /Pages /Kids [${Array.from({ length: pageBlobs.length }, (_, i) => `${i * 2 + 2} 0 R`).join(' ')}] /Count ${pageBlobs.length} >>\nendobj\n`;
                content.unshift(catalog, pagesObj);
                xref.unshift({ num: 1, offset: pdf.length }, { num: 2, offset: pdf.length + catalog.length });

                let out = pdf + content.join('');
                const xrefStart = out.length;
                out += `xref\n0 ${xref.length + 1}\n0000000000 65535 f \n`;
                xref.forEach(x => out += `${x.offset.toString().padStart(10, '0')} 00000 n \n`);
                out += `trailer\n<< /Size ${xref.length + 1} /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`;
                return new Blob([out], { type: 'application/pdf' });
            }

            function showConverted(f) {
                const converted = document.getElementById('converted');
                converted.innerHTML = '';
                if (f.type === 'application/pdf') {
                    converted.textContent = 'PDF (no preview)';
                    document.getElementById('status').textContent = `Converted: ${formatSize(f.size)}`;
                    document.getElementById('save').disabled = false;
                } else if (f.type.startsWith('image/')) {
                    const img = new Image();
                    img.onload = () => {
                        converted.appendChild(img);
                        document.getElementById('status').textContent = `Converted: ${img.width}x${img.height}, ${formatSize(f.size)}`;
                        document.getElementById('save').disabled = false;
                    };
                    img.onerror = () => {
                        document.getElementById('status').textContent = 'Error showing converted';
                        console.error('Converted image display error');
                    };
                    const url = URL.createObjectURL(f);
                    objectURLs.push(url);
                    img.src = url;
                } else if (f.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.controls = true;
                    video.onloadedmetadata = () => {
                        converted.appendChild(video);
                        document.getElementById('status').textContent = `Converted: ${video.videoWidth}x${video.videoHeight}, ${formatSize(f.size)}, ${video.duration.toFixed(1)}s`;
                        document.getElementById('save').disabled = false;
                    };
                    video.onerror = () => {
                        document.getElementById('status').textContent = 'Error showing converted';
                        console.error('Converted video display error');
                    };
                    const url = URL.createObjectURL(f);
                    objectURLs.push(url);
                    video.src = url;
                }
            }

            function save() {
                if (!output) { 
                    document.getElementById('status').textContent = 'Nothing to save'; 
                    return; 
                }
                const url = URL.createObjectURL(output);
                const a = document.createElement('a');
                a.href = url;
                a.download = output.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                document.getElementById('status').textContent = 'Saved';
            }

            function formatSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }
        })();
    </script>
</body>
</html>